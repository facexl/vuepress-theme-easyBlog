(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{197:function(t,a,e){"use strict";e.r(a);var r=e(6),v=Object(r.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"朴灵对同步异步的解释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#朴灵对同步异步的解释","aria-hidden":"true"}},[t._v("#")]),t._v(" 朴灵对同步异步的解释")]),t._v(" "),e("h3",{attrs:{id:"概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概述","aria-hidden":"true"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),e("p",[t._v("?> 异步跟"),e("code",[t._v("event loop")]),t._v("其实没有关系。准确的讲，"),e("code",[t._v("event loop")]),t._v("是实现异步的一种机制。"),e("br"),t._v("\n一般而言，操作分为：发出调用和得到结果两步。发出调用，立即得到结果是为同步。发出调用，但无法立即得到结果，需要额外的操作才能得到预期的结果是为异步。"),e("br"),t._v("\n同步就是调用之后一直等待，直到返回结果。异步则是调用之后，不能直接拿到结果，通过一系列的手段才最终拿到结果（调用之后，拿到结果中间的时间可以介入其他任务)"),e("br"),t._v("\n上面提到的一系列的手段其实就是实现异步的方法，其中就包括"),e("code",[t._v("event loop")]),t._v("。以及"),e("code",[t._v("轮询、事件")]),t._v("等。"),e("br"),t._v("\n所谓"),e("code",[t._v("轮询")]),t._v("：就是你在收银台付钱之后，坐到位置上不停的问服务员你的菜做好了没。"),e("br"),t._v("\n所谓"),e("code",[t._v("事件")]),t._v("：就是你在收银台付钱之后，你不用不停的问，饭菜做好了服务员会自己告诉你。")]),t._v(" "),e("h3",{attrs:{id:"队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#队列","aria-hidden":"true"}},[t._v("#")]),t._v(" 队列")]),t._v(" "),e("p",[t._v("?> 任务队列既不是事件的队列，也不是消息的队列"),e("br"),t._v("\n任务队列就是你在"),e("code",[t._v("主线程上的一切调用")]),t._v("\n所谓的事件驱动，就是将一切抽象为事件。IO操作完成是一个事件，用户点击一次鼠标是事件，Ajax完成了是一个事件，一个图片加载完成是一个事件,一个任务不一定产生事件，比如获取当前时间,当产生事件后，这个事件会被放进队列中，等待被处理。"),e("br"),t._v("\n异步任务不一定要回调函数，从来就没有什么执行栈。主线程永远在执行中。主线程会不断检查事件队列")]),t._v(" "),e("h3",{attrs:{id:"事件驱动"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动","aria-hidden":"true"}},[t._v("#")]),t._v(" 事件驱动")]),t._v(" "),e("p",[t._v("?> 事件驱动的的实现过程主要靠事件循环完成。进程启动后就进入主循环。主循环的过程就是不停的从事件队列里读取事件。如果事件有关联的handle(也就是注册的callback)，就执行handle。一个事件并不一定有callback")]),t._v(" "),e("h3",{attrs:{id:"语录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#语录","aria-hidden":"true"}},[t._v("#")]),t._v(" 语录")]),t._v(" "),e("p",[t._v("?> 定时器并不是特例。到达时间点后，会形成一个事件（timeout事件）。不同的是一般事件是靠底层系统或者线程池之类的产生事件，但定时器事件是靠事件循环不停检查系统时间来判定是否到达时间点来产生事件。"),e("br"),t._v("\n准确讲，使用事件驱动的系统中，必然有非常非常多的事件。如果事件都产生，都要主循环去处理，必然会导致主线程繁忙。那对于应用层的代码而言，肯定有很多不关心的事件（比如只关心点击事件，不关心定时器事件）。这会导致一定浪费。\n事实上，不是所有的事件都放置在一个队列里。"),e("br"),t._v("\n不同的事件，放置在不同的队列。"),e("br"),t._v("\n当我们没有使用定时器时，则完全不用关心定时器事件这个队列。"),e("br"),t._v(" "),e("code",[t._v("当我们进行定时器调用时，首先会设置一个定时器watcher。事件循环的过程中，会去调用该watcher，检查它的事件队列上是否产生事件（比对时间的方式。")]),e("br"),t._v(" "),e("code",[t._v("当我们进行磁盘IO的时候，则首先设置一个io watcher，磁盘IO完成后，会在该io watcher的事件队列上添加一个事件。事件循环的过程中从该watcher上处理事件。处理完已有的事件后，处理下一个watcher")]),t._v("。"),e("br"),t._v("\n检查完所有watcher后，进入下一轮检查。"),e("br"),t._v("\n对某类事件不关心时，则没有相关watcher。")])])},[],!1,null,null,null);v.options.__file="jsRunRule.md";a.default=v.exports}}]);