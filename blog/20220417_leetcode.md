---
title: Leetcode hits record
category: practice  
---  

## Leetcode hits record

::: tip
Leetcode 解题记录，包含自己的答案和社区高赞答案  
:::

### `06` Z字形变换  

```javascript
// 主要考虑使用二维数组
// 80ms 47M
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if(numRows===1){
        return s
    }
	var arr=[];
    for(var i=0;i<numRows;i++){
        arr.push([])
    }
    var j=0;
    var f=true;
    var t=0;
    while(j<s.length){
        if(t===0){
            f=true
        }
        if(t===numRows-1){
            f=false
        }
        arr[t].push(s[j])
        if(f){
            t++
        }else{
            t--
        }
        j++
    }
    var res=[]
    for(var i=0;i<arr.length;i++){
       res=res.concat(arr[i])
    }
    return res.join('')
};
```

### Community likes the answer 

```javascript
/**
 * @param {string} s
 * @param {number} numRows
 * @return {string}
 */
var convert = function(s, numRows) {
    if(numRows == 1)
        return s;

    const len = Math.min(s.length, numRows);
    const rows = [];
    for(let i = 0; i< len; i++) rows[i] = "";
    let loc = 0;
    let down = false;

    for(const c of s) {
        rows[loc] += c;
        if(loc == 0 || loc == numRows - 1)
            down = !down;
        loc += down ? 1 : -1;
    }

    let ans = "";
    for(const row of rows) {
        ans += row;
    }
    return ans;
};

作者：guanpengchn
链接：https://leetcode-cn.com/problems/zigzag-conversion/solution/hua-jie-suan-fa-6-z-zi-xing-bian-huan-by-guanpengc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### `05` 最长回文子串
给你一个字符串 s，找到 s 中最长的回文子串。

 

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"

### My answer

```javascript
// 148ms 49M
/** 思路就是当每一个字符串都是回文的中心
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    let max = ''
    for(var i=0;i<s.length;i++){
        let t = s[i]
        // 单中心
        for(var j=i-1;j>=0;j--){
            if(s[j]===s[i+i-j]){
                t = s[j]+t+s[i+i-j]
            }else{
                break
            }
        }
            if(t.length>max.length){
                max = t
            }
        // 双中心
        if(s[i]===s[i-1]){
           t = s[i-1] + s[i] 
           for(var j=i-2;j>=0;j--){
                if(s[j]===s[i+i-j-1]){
                    t = s[j]+t+s[i+i-j-1]
                }else{
                    break
                }
           } 
            if(t.length>max.length){
                max = t
            }
        }  
    }

    return max
};
```

### Community likes the answer 

```javascript
var longestPalindrome = function (s) {
    let res = ""
    for (let i = 0; i < s.length; i++) {
        // 处理奇数回文串
        const s1 = palindrome(s, i, i)
        // 处理偶数回文串
        const s2 = palindrome(s, i, i + 1)
        res = res.length <= s1.length ? s1 : res
        res = res.length <= s2.length ? s2 : res
    }
    return res
};

// 返回以l,r为中心点扩散的最长回文串
function palindrome(s, l, r) {
    while (l >= 0 && r < s.length && s[l] === s[r]) {
        l--
        r++
    }
    return s.slice(l + 1, r)
}

作者：ruo-n8
链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-chuan-shi-yong-shuang-cc725/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### `04`  无重复字符的最长子串
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

算法的时间复杂度应该为 O(log (m+n)) 。

 

示例 1：

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
示例 2：

输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
### My answer

```javascript
// 注意：这个回答复杂度不达标 排序复杂度 O((m+n) log(m+n))不符合题意，题目要求的是O(log (m+n))
// 88ms 46M
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number}
 */
var findMedianSortedArrays = function(nums1, nums2) {
    const res = nums1.concat(nums2).sort((a,b)=>a-b)
    return res.length%2===0?(res[res.length/2-1]+res[res.length/2])/2:res[Math.floor(res.length/2)]
};

```

### Community likes the answer 

```javascript
var findMedianSortedArrays = (nums1, nums2) => {
    let len1 = nums1.length, len2 = nums2.length
    if (len1 > len2) return findMedianSortedArrays(nums2, nums1)//对nums1和nums2中长度较小的二分
    let len = len1 + len2//总长
    let start = 0, end = len1 //进行二分的开始和结束位置
    let partLen1, partLen2

    while (start <= end) {
        partLen1 = (start + end) >> 1//nums1二分的位置
        partLen2 = ((len + 1) >> 1) - partLen1//nums2二分的位置

        //L1:nums1二分之后左边的位置，L2，nums1二分之后右边的位置
        //R1:nums2二分之后左边的位置，R2，nums2二分之后右边的位置

        //如果左边没字符了，就定义成-Infinity，让所有数都大于它，否则就是nums1二分的位置左边一个
        let L1 = partLen1 === 0 ? -Infinity : nums1[partLen1 - 1]
        //如果左边没字符了，就定义成-Infinity，让所有数都大于它，否则就是nums2二分的位置左边一个
        let L2 = partLen2 === 0 ? -Infinity : nums2[partLen2 - 1]
        //如果右边没字符了，就定义成Infinity，让所有数都小于它，否则就是nums1二分的位置
        let R1 = partLen1 === len1 ? Infinity : nums1[partLen1]
        //如果右边没字符了，就定义成Infinity，让所有数都小于它，否则就是nums1二分的位置
        let R2 = partLen2 === len2 ? Infinity : nums2[partLen2]

        if (L1 > R2) {//不符合交叉小于等于 继续二分
            end = partLen1 - 1
        } else if (L2 > R1) {//不符合交叉小于等于 继续二分
            start = partLen1 + 1
        } else { // L1 <= R2 && L2 <= R1 符合交叉小于等于
            return len % 2 === 0 ?
                (Math.max(L1, L2) + Math.min(R1, R2)) / 2 : //长度为偶数返回作左侧较大者和右边较小者和的一半
                Math.max(L1, L2)	//长度为奇数返回作左侧较大者
        }
    }
}

作者：chen-wei-f
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/er-fen-tu-jie-dai-ma-jian-ji-by-chen-wei-c3u4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### `03`  无重复字符的最长子串

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

 

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
### My answer

```javascript

// 72ms 47M
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    let last='';
    let current='';
    for(let i=0;i<s.length;i++){
        if(current.indexOf(s[i])===-1){
            current = current+s[i]
        }else{
            if(current.length>last.length){
                last = current
            }
            current = current.substring(current.indexOf(s[i])+1)+s[i]
        }
        
    }
    return current.length>last.length?current.length:last.length
};
```

### Community likes the answer  

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
        let index = 0, max = 0
    for(let i = 0, j = 0; j < s.length; j++) {
        index = s.substring(i, j).indexOf(s[j]) 
        if(index !== -1) { 
            i = i + index + 1 
        } 
        max = Math.max(max, j - i + 1) 
    }
    return max
};
作者：user7746o
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/zi-jie-leetcode3wu-zhong-fu-zi-fu-de-zui-chang-zi-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### `02`  两数想加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例 1：
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]

### My answer
```javascript
// 104ms 47M
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    var res;
    function add(x,y,r,nv){
        var arr = String(x.val+y.val+(nv||0)).split('')
        var currentV = arr.length>1?+arr[1]:+arr[0]
        var nextV = arr.length>1?+arr[0]:0
        if(r!==undefined){
           r.next = new ListNode(currentV)     
        }else{
           res = new ListNode(currentV)
        }
        if(x.next!==null || y.next!==null ||nextV !==0){            
            add(x.next===null?{val:0,next:null}:x.next,y.next===null?{val:0,next:null}:y.next,r===undefined?res:r.next,nextV)
        }  
    }
    add(l1,l2)
    return res
};

```

根据'所有递归可以改成 while 定律'  可以修改代码

```javascript
// 92ms 47M
var addTwoNumbers = function(l1, l2) {
    let x = l1;
    let y = l2;
    let res,nextV,r;
    while(x!==null || y!==null || nextV !==0){
        var str = String((x?x.val:0)+(y?y.val:0)+(nextV||0))
        var currentV = str.length>1?+str[1]:+str[0]
        nextV = str.length>1?+str[0]:0
        if(r!==undefined){
           r.next = new ListNode(currentV)  
           r = r.next
        }else{
           res = new ListNode(currentV)
           r = res
        }
        x = x?x.next:null
        y = y?y.next:null
    }
    return res
};
```

### Community likes the answer  

```javascript
var addTwoNumbers = function (l1, l2) {
  if (!l1 && !l2) return null
  // 链表头
  let head = null
  // 当前链表位置
  tail = null
  // 存放当前计算的值
  let sum = 0
  // 存放进位
  let remainder = 0

  while (l1 || l2) {
    //  取读链表中当前位置的值(指针)
    let n1 = l1 ? l1.val : 0
    let n2 = l2 ? l2.val : 0
    // 计算
    sum = n1 + n2 + remainder
    // 计算进位(满十进一)
    remainder = Math.floor(sum / 10)
    // 存入计算的值(取个位)
    if (!head) {
      // 链表头
      head = tail = new ListNode(sum % 10)
    } else {
      // 链表向下链接
      tail.next = new ListNode(sum % 10)
      // 更新链表位置(指针++)
      tail = tail.next
    }
    // 更新链表位置(指针++)
    if (l1) {
      l1 = l1.next
    }
    if (l2) {
      l2 = l2.next
    }
  }

  // 存在进位 则链表下一项进一位
  if (remainder) tail.next = new ListNode(1)

  return head
}

作者：mo-lu-9d
链接：https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-xian-du-ti-du-ti-fen-oda7/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```

::: tip
本题的参数实际是 new ListNode(2,new ListNode(4,...))
:::

### `01` 两数之和 
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]

### My answer
```javascript
// 72ms 42M
var twoSum = function(nums, target) {
    var hash={};
    for(var i=0;i<nums.length;i++){
       if(typeof hash[target-nums[i]]==='number'){
           return [hash[target-nums[i]],i]
       }
        hash[nums[i]]=i
    }
};
```
### Community likes the answer  
```javascript
const twoSum = (nums, target) => {
  const prevNums = {};                    // 存储出现过的数字，和对应的索引               

  for (let i = 0; i < nums.length; i++) {       // 遍历元素   
    const curNum = nums[i];                     // 当前元素   
    const targetNum = target - curNum;          // 满足要求的目标元素   
    const targetNumIndex = prevNums[targetNum]; // 在prevNums中获取目标元素的索引
    if (targetNumIndex !== undefined) {         // 如果存在，直接返回 [目标元素的索引,当前索引]
      return [targetNumIndex, i];
    } else {                                    // 如果不存在，说明之前没出现过目标元素
      prevNums[curNum] = i;                     // 存入当前的元素和对应的索引
    }
  }
}

作者：xiao_ben_zhu
链接：https://leetcode-cn.com/problems/two-sum/solution/qing-xi-de-bian-liang-ming-ming-bang-zhu-ji-yi-bu-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
::: tip
Hash 大法好！
:::