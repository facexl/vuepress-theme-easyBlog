---
title: Leetcode hits record
category: practice  
---  

## Leetcode hits record

::: tip
Leetcode 解题记录，包含自己的答案和社区高赞答案  
:::

### `03`  无重复字符的最长子串

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

 

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
### My answer

```javascript

// 72ms 47M
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
    let last='';
    let current='';
    for(let i=0;i<s.length;i++){
        if(current.indexOf(s[i])===-1){
            current = current+s[i]
        }else{
            if(current.length>last.length){
                last = current
            }
            current = current.substring(current.indexOf(s[i])+1)+s[i]
        }
        
    }
    return current.length>last.length?current.length:last.length
};
```

### Community likes the answer  

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function(s) {
        let index = 0, max = 0
    for(let i = 0, j = 0; j < s.length; j++) {
        index = s.substring(i, j).indexOf(s[j]) 
        if(index !== -1) { 
            i = i + index + 1 
        } 
        max = Math.max(max, j - i + 1) 
    }
    return max
};
作者：user7746o
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/zi-jie-leetcode3wu-zhong-fu-zi-fu-de-zui-chang-zi-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### `02`  两数想加
给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例 1：
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
示例 2：

输入：l1 = [0], l2 = [0]
输出：[0]
示例 3：

输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]

### My answer
```javascript
// 104ms 47M
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    var res;
    function add(x,y,r,nv){
        var arr = String(x.val+y.val+(nv||0)).split('')
        var currentV = arr.length>1?+arr[1]:+arr[0]
        var nextV = arr.length>1?+arr[0]:0
        if(r!==undefined){
           r.next = new ListNode(currentV)     
        }else{
           res = new ListNode(currentV)
        }
        if(x.next!==null || y.next!==null ||nextV !==0){            
            add(x.next===null?{val:0,next:null}:x.next,y.next===null?{val:0,next:null}:y.next,r===undefined?res:r.next,nextV)
        }  
    }
    add(l1,l2)
    return res
};

```

根据'所有递归可以改成 while 定律'  可以修改代码

```javascript
// 92ms 47M
var addTwoNumbers = function(l1, l2) {
    let x = l1;
    let y = l2;
    let res,nextV,r;
    while(x!==null || y!==null || nextV !==0){
        var str = String((x?x.val:0)+(y?y.val:0)+(nextV||0))
        var currentV = str.length>1?+str[1]:+str[0]
        nextV = str.length>1?+str[0]:0
        if(r!==undefined){
           r.next = new ListNode(currentV)  
           r = r.next
        }else{
           res = new ListNode(currentV)
           r = res
        }
        x = x?x.next:null
        y = y?y.next:null
    }
    return res
};
```

### Community likes the answer  

```javascript
var addTwoNumbers = function (l1, l2) {
  if (!l1 && !l2) return null
  // 链表头
  let head = null
  // 当前链表位置
  tail = null
  // 存放当前计算的值
  let sum = 0
  // 存放进位
  let remainder = 0

  while (l1 || l2) {
    //  取读链表中当前位置的值(指针)
    let n1 = l1 ? l1.val : 0
    let n2 = l2 ? l2.val : 0
    // 计算
    sum = n1 + n2 + remainder
    // 计算进位(满十进一)
    remainder = Math.floor(sum / 10)
    // 存入计算的值(取个位)
    if (!head) {
      // 链表头
      head = tail = new ListNode(sum % 10)
    } else {
      // 链表向下链接
      tail.next = new ListNode(sum % 10)
      // 更新链表位置(指针++)
      tail = tail.next
    }
    // 更新链表位置(指针++)
    if (l1) {
      l1 = l1.next
    }
    if (l2) {
      l2 = l2.next
    }
  }

  // 存在进位 则链表下一项进一位
  if (remainder) tail.next = new ListNode(1)

  return head
}

作者：mo-lu-9d
链接：https://leetcode-cn.com/problems/add-two-numbers/solution/liang-shu-xiang-jia-xian-du-ti-du-ti-fen-oda7/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```

::: tip
本题的参数实际是 new ListNode(2,new ListNode(4,...))
:::

### `01` 两数之和 
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]

### My answer
```javascript
// 72ms 42M
var twoSum = function(nums, target) {
    var hash={};
    for(var i=0;i<nums.length;i++){
       if(typeof hash[target-nums[i]]==='number'){
           return [hash[target-nums[i]],i]
       }
        hash[nums[i]]=i
    }
};
```
### Community likes the answer  
```javascript
const twoSum = (nums, target) => {
  const prevNums = {};                    // 存储出现过的数字，和对应的索引               

  for (let i = 0; i < nums.length; i++) {       // 遍历元素   
    const curNum = nums[i];                     // 当前元素   
    const targetNum = target - curNum;          // 满足要求的目标元素   
    const targetNumIndex = prevNums[targetNum]; // 在prevNums中获取目标元素的索引
    if (targetNumIndex !== undefined) {         // 如果存在，直接返回 [目标元素的索引,当前索引]
      return [targetNumIndex, i];
    } else {                                    // 如果不存在，说明之前没出现过目标元素
      prevNums[curNum] = i;                     // 存入当前的元素和对应的索引
    }
  }
}

作者：xiao_ben_zhu
链接：https://leetcode-cn.com/problems/two-sum/solution/qing-xi-de-bian-liang-ming-ming-bang-zhu-ji-yi-bu-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```
::: tip
Hash 大法好！
:::